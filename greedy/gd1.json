{
  "id": "dijkstra_algorithm",
  "title": "Dijkstra Algorithm",
  "description": "Learn how to implement Dijkstra's algorithm to find the shortest path in a weighted graph. This article covers the algorithm, its implementation, and proofs of correctness.",
  "data": "# Dijkstra Algorithm\n\nYou are given a directed or undirected weighted graph with $n$ vertices and $m$ edges. The weights of all edges are non-negative. You are also given a starting vertex $s$. This article discusses finding the lengths of the shortest paths from a starting vertex $s$ to all other vertices, and output the shortest paths themselves.\n\nThis problem is also called **single-source shortest paths problem**.\n\n## Algorithm\n\nHere is an algorithm described by the Dutch computer scientist Edsger W. Dijkstra in 1959.\n\nLet's create an array $d[]$ where for each vertex $v$ we store the current length of the shortest path from $s$ to $v$ in $d[v]$. Initially $d[s] = 0$, and for all other vertices this length equals infinity.\n\n$$d[v] = \\infty,~ v \\ne s$$\n\nIn addition, we maintain a Boolean array $u[]$ which stores for each vertex $v$ whether it's marked. Initially all vertices are unmarked:\n\n$$u[v] = {\\rm false}$$\n\nThe Dijkstra's algorithm runs for $n$ iterations. At each iteration a vertex $v$ is chosen as unmarked vertex which has the least value $d[v]$:\n\nEvidently, in the first iteration the starting vertex $s$ will be selected.\n\nThe selected vertex $v$ is marked. Next, from vertex $v$ **relaxations** are performed: all edges of the form $(v,\\text{to})$ are considered, and for each vertex $\\text{to}$ the algorithm tries to improve the value $d[\\text{to}]$. If the length of the current edge equals $len$, the code for relaxation is:\n\n$$d[\\text{to}] = \\min (d[\\text{to}], d[v] + len)$$\n\nAfter all such edges are considered, the current iteration ends. Finally, after $n$ iterations, all vertices will be marked, and the algorithm terminates. We claim that the found values $d[v]$ are the lengths of shortest paths from $s$ to all vertices $v$.\n\nNote that if some vertices are unreachable from the starting vertex $s$, the values $d[v]$ for them will remain infinite. Obviously, the last few iterations of the algorithm will choose those vertices, but no useful work will be done for them. Therefore, the algorithm can be stopped as soon as the selected vertex has infinite distance to it.\n\n### Restoring Shortest Paths\n\nUsually one needs to know not only the lengths of shortest paths but also the shortest paths themselves. Let's see how to maintain sufficient information to restore the shortest path from $s$ to any vertex. We'll maintain an array of predecessors $p[]$ in which for each vertex $v \\ne s$, $p[v]$ is the penultimate vertex in the shortest path from $s$ to $v$. Here we use the fact that if we take the shortest path to some vertex $v$ and remove $v$ from this path, we'll get a path ending in at vertex $p[v]$, and this path will be the shortest for the vertex $p[v]$. This array of predecessors can be used to restore the shortest path to any vertex: starting with $v$, repeatedly take the predecessor of the current vertex until we reach the starting vertex $s$ to get the required shortest path with vertices listed in reverse order. So, the shortest path $P$ to the vertex $v$ is equal to:\n\n$$P = (s, \\ldots, p[p[p[v]]], p[p[v]], p[v], v)$$\n\nBuilding this array of predecessors is very simple: for each successful relaxation, i.e. when for some selected vertex $v$, there is an improvement in the distance to some vertex $\\text{to}$, we update the predecessor vertex for $\\text{to}$ with vertex $v$:\n\n$$p[\\text{to}] = v$$\n\n## Proof\n\nThe main assertion on which Dijkstra's algorithm correctness is based is the following:\n\n**After any vertex $v$ becomes marked, the current distance to it $d[v]$ is the shortest, and will no longer change.**\n\nThe proof is done by induction. For the first iteration this statement is obvious: the only marked vertex is $s$, and the distance to is $d[s] = 0$ is indeed the length of the shortest path to $s$. Now suppose this statement is true for all previous iterations, i.e. for all already marked vertices; let's prove that it is not violated after the current iteration completes. Let $v$ be the vertex selected in the current iteration, i.e. $v$ is the vertex that the algorithm will mark. Now we have to prove that $d[v]$ is indeed equal to the length of the shortest path to it $l[v]$.\n\nConsider the shortest path $P$ to the vertex $v$. This path can be split into two parts: $P_1$ which consists of only marked nodes (at least the starting vertex $s$ is part of $P_1$), and the rest of the path $P_2$ (it may include a marked vertex, but it always starts with an unmarked vertex). Let's denote the first vertex of the path $P_2$ as $p$, and the last vertex of the path $P_1$ as $q$.\n\nFirst we prove our statement for the vertex $p$, i.e. let's prove that $d[p] = l[p]$.\n\nThis is almost obvious: on one of the previous iterations we chose the vertex $q$ and performed relaxation from it.\nSince (by virtue of the choice of vertex $p$) the shortest path to $p$ is the shortest path to $q$ plus edge $(p,q)$, the relaxation from $q$ set the value of $d[p]$ to the length of the shortest path $l[p]$.\n\nSince the edges' weights are non-negative, the length of the shortest path $l[p]$ (which we just proved to be equal to $d[p]$) does not exceed the length $l[v]$ of the shortest path to the vertex $v$. Given that $l[v] \\le d[v]$ (because Dijkstra's algorithm could not have found a shorter way than the shortest possible one), we get the inequality:\n\n$$d[p] = l[p] \\le l[v] \\le d[v]$$\n\nOn the other hand, since both vertices $p$ and $v$ are unmarked, and the current iteration chose vertex $v$, not $p$, we get another inequality:\n\n$$d[p] \\ge d[v]$$\n\nFrom these two inequalities we conclude that $d[p] = d[v]$, and then from previously found equations we get:\n\n$$d[v] = l[v]$$\n\nQ.E.D.\n\n## Implementation\n\nDijkstra's algorithm performs $n$ iterations. On each iteration it selects an unmarked vertex $v$ with the lowest value $d[v]$, marks it and checks all the edges $(v, \\text{to})$ attempting to improve the value $d[\\text{to}]$.\n\nThe running time of the algorithm consists of:\n\n* $n$ searches for a vertex with the smallest value $d[v]$ among $O(n)$ unmarked vertices\n* $m$ relaxation attempts\n\nFor the simplest implementation of these operations on each iteration vertex search requires $O(n)$ operations, and each relaxation can be performed in $O(1)$. Hence, the resulting asymptotic behavior of the algorithm is:\n\n$$O(n^2+m)$$\n\nThis complexity is optimal for dense graph, i.e. when $m \\approx n^2$.\nHowever in sparse graphs, when $m$ is much smaller than the maximal number of edges $n^2$, the problem can be solved in $O(n \\log n + m)$ complexity. The algorithm and implementation can be found on the article [Dijkstra on sparse graphs](dijkstra_sparse.md).\n\n```{.cpp file=dijkstra_dense}\nconst int INF = 1000000000;\nvector<vector<pair<int, int>>> adj;\n\nvoid dijkstra(int s, vector<int> & d, vector<int> & p) {\n    int n = adj.size();\n    d.assign(n, INF);\n    p.assign(n, -1);\n    vector<bool> u(n, false);\n\n    d[s] = 0;\n    for (int i = 0; i < n; i++) {\n        int v = -1;\n        for (int j = 0; j < n; j++) {\n            if (!u[j] && (v == -1 || d[j] < d[v]))\n                v = j;\n        }\n        if (d[v] == INF)\n            break;\n        u[v] = true;\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n            if (d[v] + len < d[to]) {\n                d[to] = d[v] + len;\n                p[to] = v;\n            }\n        }\n    }\n}\n```\n\nHere the graph $\\text{adj}$ is stored as adjacency list: for each vertex $v$ $\\text{adj}[v]$ contains the list of edges going from this vertex, i.e. the list of `pair<int,int>` where the first element in the pair is the vertex at the other end of the edge, and the second element is the edge weight.\n\nThe function takes the starting vertex $s$ and two vectors that will be used as return values.\n\nFirst of all, the code initializes arrays: distances $d[]$, labels $u[]$ and predecessors $p[]$. Then it performs $n$ iterations. At each iteration the vertex $v$ is selected which has the smallest distance $d[v]$ among all the unmarked vertices. If the distance to selected vertex $v$ is equal to infinity, the algorithm stops. Otherwise the vertex is marked, and all the edges going out from this vertex are checked. If relaxation along the edge is possible (i.e. distance $d[\\text{to}]$ can be improved), the distance $d[\\text{to}]$ and predecessor $p[\\text{to}]$ are updated.\n\nAfter performing all the iterations array $d[]$ stores the lengths of the shortest paths to all vertices, and array $p[]$ stores the predecessors of all vertices (except starting vertex $s$). The path to any vertex $t$ can be restored in the following way:\n\n```{.cpp file=dijkstra_restore_path}\nvector<int> restore_path(int s, int t, vector<int> const& p) {\n    vector<int> path;\n    for (int v = t; v != s; v = p[v])\n        path.push_back(v);\n    path.push_back(s);\n    reverse(path.begin(), path.end());\n    return path;\n}\n```\n\n## References\n\n* Edsger Dijkstra. A note on two problems in connexion with graphs [1959]\n* Thomas Cormen, Charles Leiserson, Ronald Rivest, Clifford Stein. Introduction to Algorithms [2005]",
  "problems": [
    {
      "id": "dijkstra_problem_1",
      "name": "Timus - Ivan's Car",
      "difficulty": "Medium"
    },
    {
      "id": "dijkstra_problem_2",
      "name": "Timus - Sightseeing Trip",
      "difficulty": "Medium"
    },
    {
      "id": "dijkstra_problem_3",
      "name": "SPOJ - SHPATH",
      "difficulty": "Easy"
    },
    {
      "id": "dijkstra_problem_4",
      "name": "Codeforces - Dijkstra?",
      "difficulty": "Easy"
    },
    {
      "id": "dijkstra_problem_5",
      "name": "SPOJ - Easy Dijkstra Problem",
      "difficulty": "Easy"
    }
  ]
}
